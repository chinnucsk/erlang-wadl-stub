%%% @doc Generates a REST API module out of a WADL file.
-module(wadl).

%%%_* Exports ==========================================================
-export([ create_wadl_hrl/0
        , generate_module/2
        , parse_wadl/1
        ]).

%%%_* Includes =========================================================
-include_lib("waderl/include/wadl.hrl").

%%%_* Code =============================================================
%%%_* API --------------------------------------------------------------
%% @doc Given the content of a WADL xml file, return a list data structure with
%% the REST api tree.
-spec parse_wadl(WADLSource::string()) -> [_].

parse_wadl(WADLSource) ->
  Schema      = priv_file("wadl.xsd"),
  {ok, Model} = erlsom:compile_xsd_file(Schema),
  {ok, WADL}  = erlsom:parse(WADLSource, Model),
  collect_application(WADL).

%% @doc Write an Erlang module with the REST API to a given filename.
-spec generate_module(WADL::[_], Filename::string()) -> ok.

generate_module(WADL, Filename) ->
  Module = filename:basename(Filename, ".erl"),
  APIModule = "-module("++Module++").\n-compile(export_all).\n\n" ++
    lists:flatmap(fun(API) -> format_api(API)++"\n" end, WADL),
  file:write_file(Filename, APIModule).

%% @doc Create an XSD header file with all WADL record definitions for Erlsom.
-spec create_wadl_hrl() -> ok.

create_wadl_hrl() ->
  SchemaFilename = priv_file("wadl.xsd"),
  RecDefFilename = "include/wadl.hrl",
  erlsom:write_xsd_hrl_file(SchemaFilename, RecDefFilename).

%%%_* Internals --------------------------------------------------------
format_api({Name, Method, Path0, [], []}) ->
  Path = io_lib:format("\"~s\"", [Path0]),
  io_lib:format("~p() -> ", [Name]) ++
  io_lib:format("rest_client:request(~p, ~s).", [Method, Path]);
format_api({Name, Method, Path0, [], _ReqParams}) ->
  Path = io_lib:format("\"~s\"", [Path0]),
  io_lib:format("~p(Data) -> ", [Name]) ++
  io_lib:format("rest_client:request(~p, ~s, Data).", [Method, Path]);
format_api({Name, Method, Path0, ResParams, []}) ->
  Params = format_params(ResParams),
  Path   = format_path(Path0, ResParams),
  io_lib:format("~p(~s) -> ", [Name, string:join(Params, ", ")]) ++
  io_lib:format("rest_client:request(~p, \"~s\").", [Method, Path]);
format_api({Name, Method, Path0, ResParams, _ReqParams}) ->
  Params = format_params(ResParams),
  Path   = format_path(Path0, ResParams),
  io_lib:format("~p(~s, Data) -> ", [Name, string:join(Params, ", ")]) ++
  io_lib:format("rest_client:request(~p, \"~s\", Data).", [Method, Path]).

format_params(Params) ->
  ["P"++Key || {Key, _} <- Params].

format_path(Path, Params) ->
  Fun = fun({Key, _}, P) ->
            RegExp  = "{"++Key++"}",
            Replace = "\"++P"++Key++"++\"",
            re:replace(P, RegExp, Replace, [{return, list}])
        end,
  lists:foldl(Fun, Path, Params).

collect_application(#application{resources=Resources}) ->
  lists:flatten(collect_resources(Resources)).

collect_resources([]) -> [];
collect_resources([#resources{ base=Base
                             , resource=Resource}|T]) ->
  Resources = collect_resource(Base, Resource),
  [Resources|collect_resources(T)].

collect_resource(_,    []) -> [];
collect_resource(Base, [#resource{ path=Path
                                 , param=Params
                                 , choice=Choices}|T]) ->
  Resource = collect_resource(join_path(Base, Path), Params, Choices),
  [Resource|collect_resource(Base, T)].

collect_resource(_,    _,      []) -> [];
collect_resource(Path, Params, [#resource{}=H|T]) ->
  Resource = collect_resource(Path, [H]),
  [Resource|collect_resource(Path, Params, T)];
collect_resource(Path, Params, [#method{ id=Id
                                        , name=Name
                                        , request=Request}|T]) ->
  ResourceParams = collect_param(Params),
  RequestParams  = collect_request(Request),
  Resource = { erlang:list_to_atom(Id)
             , map_method(Name)
             , Path
             , ResourceParams
             , RequestParams
             },
  [Resource|collect_resource(Path, Params, T)].

collect_request(undefined) -> [];
collect_request(#request{param=Param}) ->
  collect_param(Param).

collect_param([]) -> [];
collect_param(undefined) -> [];
collect_param([#param{style="query", name=Name, type=Type}|T]) ->
  [{Name, map_type(Type)}|collect_param(T)];
collect_param([#param{style="template", name=Name, type=Type}|T]) ->
  [{Name, map_type(Type)}|collect_param(T)].

%% FIXME Should be a record, but wasn't generated by erlsom.
map_type({qname, _href, "int",    "xs", "xsd"}) -> integer;
map_type({qname, _href, "long",   "xs", "xsd"}) -> integer;
map_type({qname, _href, "string", "xs", "xsd"}) -> string.

map_method("OPTIONS") -> options;
map_method("GET")     -> get;
map_method("HEAD")    -> head;
map_method("POST")    -> post;
map_method("PUT")     -> put;
map_method("DELETE")  -> delete;
map_method("TRACE")   -> trace;
map_method("CONNECT") -> connect.

%%%_* Helpers ----------------------------------------------------------
join_path(Path1, Path2) ->
  string:strip(Path1, right, $/) ++ "/" ++ string:strip(Path2, left, $/).

%% Can't use code:priv_dir/1 as the application is usually not loaded.
priv_file(Filename) ->
  filename:join([ filename:dirname(code:which(?MODULE)), "../priv", Filename]).

%%% Mode: Erlang
%%% End.
